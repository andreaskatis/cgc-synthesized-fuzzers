type USER_byte = int;

node initially(
  signal : bool
) returns (
  holds : bool
);
let
  holds = (signal -> true);

tel;

node historically(
  signal : bool
) returns (
  holds : bool
);
let
  holds = (signal and (true -> (pre holds)));

tel;

node once(
  signal : bool
) returns (
  holds : bool
);
let
  holds = (signal or (false -> (pre holds)));

tel;

node since(
  a : bool;
  b : bool
) returns (
  holds : bool
);
let
  holds = (b or (a and (false -> (pre holds))));

tel;

node triggers(
  a : bool;
  b : bool
) returns (
  holds : bool
);
let
  holds = (b and (a or (false -> (pre holds))));

tel;

node responds(
  a : bool;
  b : bool;
  n : int
) returns (
  holds : bool
);
var
  latch : int;
  i : int;
  pre_state : int;
  state : int;
let
  latch = (n -> (pre latch));

  pre_state = (0 -> (pre state));

  state = (if (pre_state = 0) then (if ((not b) or (a and b)) then 0 else 1) else (if (pre_state = 1) then (if ((not a) and (i < latch)) then 1 else (if (a and b) then 1 else (if ((not a) and (i >= latch)) then 2 else 0))) else 2));

  i = (if (pre_state = 0) then 0 else (if (pre_state = 1) then (if (not a) then ((pre i) + 1) else (if (a and b) then 0 else (pre i))) else (pre i)));

  holds = ((state = 0) or (state = 1));

tel;

node precedes(
  a : bool;
  b : bool
) returns (
  holds : bool
);
var
  state : int;
  pre_state : int;
let
  pre_state = (0 -> (pre state));

  state = (if (pre_state = 0) then (if ((a and b) or ((not a) and (not b))) then 0 else (if (a and (not b)) then 1 else 2)) else (if (pre_state = 1) then (if b then 0 else 1) else 2));

  holds = ((state = 0) or (state = 1));

tel;

node count(
  a : bool
) returns (
  c : int
);
let
  c = ((0 -> (pre c)) + (if a then 1 else 0));

tel;

node ccount(
  a : bool
) returns (
  c : int
);
let
  c = (if a then ((0 -> (pre c)) + 1) else 0);

tel;

node btoi(
  a : bool
) returns (
  c : int
);
let
  c = (if a then 1 else 0);

tel;

node USER_little(
  USER_i : USER_byte;
  USER_st : int
) returns (
  constraints : bool
);
var
  USER_pre_st : int;
  USER_otype : bool;
  USER_st0_1 : bool;
  USER_st0_2 : bool;
  USER_st0_n : bool;
  USER_stn_1 : bool;
  USER_stn_2 : bool;
  USER_stn_n : bool;
  USER_st1_1 : bool;
  USER_st1_2 : bool;
  USER_st1_n : bool;
  USER_st2_0 : bool;
  USER_st2_1 : bool;
  USER_st2_2 : bool;
  USER_st2_n : bool;
  USER_i_satisfies_predicate : bool;
  counter : int;
let
  --%MAIN;
  counter = (1 -> ((pre counter) + 1));

  USER_pre_st = (0 -> (pre USER_st));

  USER_otype = ((0 <= USER_i) and (USER_i <= 255));

  USER_st0_1 = ((USER_pre_st = 0) => ((USER_i = 1) => (USER_st = 1)));

  USER_st0_2 = ((USER_pre_st = 0) => ((USER_i = 2) => (USER_st = 2)));

  USER_st0_n = ((USER_pre_st = 0) => (((USER_i < 1) or (USER_i > 2)) => (USER_st = (-1))));

  USER_stn_1 = ((USER_pre_st = (-1)) => ((USER_i = 1) => (USER_st = 1)));

  USER_stn_2 = ((USER_pre_st = (-1)) => ((USER_i = 2) => (USER_st = 2)));

  USER_stn_n = ((USER_pre_st = (-1)) => (((USER_i < 1) or (USER_i > 2)) => (USER_st = (-1))));

  USER_st1_1 = ((USER_pre_st = 1) => ((USER_i = 1) => (USER_st = 1)));

  USER_st1_2 = ((USER_pre_st = 1) => ((USER_i = 2) => (USER_st = 2)));

  USER_st1_n = ((USER_pre_st = 1) => (((USER_i < 1) or (USER_i > 2)) => (USER_st = (-1))));

  USER_st2_0 = ((USER_pre_st = 2) => ((USER_i = 0) => (USER_st = 0)));

  USER_st2_1 = ((USER_pre_st = 2) => ((USER_i = 1) => (USER_st = 1)));

  USER_st2_2 = ((USER_pre_st = 2) => ((USER_i = 2) => (USER_st = 2)));

  USER_st2_n = ((USER_pre_st = 2) => (((USER_i < 0) or (USER_i > 2)) => (USER_st = (-1))));

  USER_i_satisfies_predicate = ((0 <= USER_i) and (USER_i <= 255));

  constraints = historically((USER_otype and (USER_st0_1 and (USER_st0_2 and (USER_st0_n and (USER_stn_1 and (USER_stn_2 and (USER_stn_n and (USER_st1_1 and (USER_st1_2 and (USER_st1_n and (USER_st2_0 and (USER_st2_1 and (USER_st2_2 and USER_st2_n))))))))))))));

  --%PROPERTY constraints;

  --%REALIZABLE ;

tel;
